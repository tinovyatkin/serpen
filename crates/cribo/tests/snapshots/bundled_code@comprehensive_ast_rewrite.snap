---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/bundling/comprehensive_ast_rewrite/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

from typing import Any, Dict, List, Optional
import sys
import types
result_models_base = "base_result"
process_models_base_1 = "base_process_string"
class BaseModel_models_base:
	"""Base model class with method name conflicts"""

	def __init__(self, model_type: str):
		self.model_type = model_type
		self.initialized = False
		self.validate = self._base_validate
		self.process = self._base_process
		self.Logger = Logger_2("base_model")

	def _base_validate(self, data: Any) -> bool:
		"""Base validation using relative imports"""
		return validate_6(data)

	def _base_process(self, data: Any) -> str:
		"""Base processing with conflicts"""
		validated = self.validate(data)
		if validated:
			self.Logger._log_process(f'Base processing: {data}')
			return f'base_processed: {data}'
		return "base_invalid"

	def initialize(self) -> str:
		"""Initialize with name conflicts"""
		global result_models_base
		self.initialized = True
		result_models_base = f'base_initialized_{self.model_type}'
		return result_models_base
def initialize_models_base() -> str:
	"""Module initialization function"""
	global result_models_base
	base = BaseModel_models_base("default")
	init_result = base.initialize()
	logger = Logger_2("base_init")
	logger._log_process("Base module initialized")
	result_models_base = f'module_init: {init_result}'
	return result_models_base
def validate_models_base(data: Any) -> bool:
	"""Base validate function - conflicts everywhere"""
	return validate_6(data) and data != "invalid"
def process_models_base_1(data: Any) -> str:
	"""Base process function - conflicts everywhere"""
	global result_models_base
	validated = validate_models_base(data)
	if validated:
		processed = f'base_module_process: {data}'
	else:
		processed = "base_module_invalid"
	result_models_base = f'base_last_process: {processed}'
	return processed
class Logger_models_base:
	"""Base Logger class - yet another Logger conflict"""

	def __init__(self, source: str):
		self.source = source
		self.logs = []

	def log(self, message: str) -> None:
		self.logs.append(f'[BASE {self.source}] {message}')

	def process(self, log_data: Any) -> str:
		"""Logger process method - conflicts with global process"""
		self.log(f'Processing: {log_data}')
		return f'base_logger_process: {log_data}'
def connect_models_base() -> str:
	"""Base connect function"""
	return "base_connected"
def shadow_test_models_base(validate: Any=None, process: Any=None, Logger: Any=None, result: Any=None, initialize: Any=None) -> Dict[str, Any]:
	"""Function that shadows all major conflict names with parameters"""
	shadows = {"validate_param": validate_models_base, "process_param": process_models_base_1, "Logger_param": Logger_models_base, "result_param": result_models_base, "initialize_param": initialize_models_base}
	validate_models_base = globals()["validate"]
	process_models_base_1 = globals()["process"]
	Logger_models_base = globals()["Logger"]
	validation_result = validate_models_base("test_data")
	process_result = process_models_base_1("test_data")
	logger = Logger_models_base("shadow_test")
	shadows.update({"global_validate_result": validation_result, "global_process_result": process_result, "global_logger_source": logger.source})
	return shadows
process_3 = "models_process_string"
validate_3 = "models_validate_string"
connection_2 = "models_connection_string"
"""
User model with extensive naming conflicts across the project
"""
result_3 = {"model": "user"}
connection_3 = None
class Logger_2:
	"""Model Logger class - conflicts with other Logger classes"""

	def __init__(self, context: str):
		self.context = context
		self.entries = []
		self.process = self._log_process

	def _log_process(self, message: str) -> None:
		self.entries.append(f"{self.context}: {message}")

	def get_message(self) -> str:
		return f"Model Logger: {self.context}"

	def validate(self, entry: str) -> bool:
		"""Method with name that conflicts with global functions"""
		return len(entry) > 0
class User_2:
	"""Model User class - major conflict with other User classes"""

	def __init__(self, name: str, email: str=""):
		self.name = name
		self.email = email
		self.active = True
		self.Logger = Logger_2(f"user_{name}")
		self.process = self._user_process
		self.validate = self._user_validate
		self.result = None

	def _user_process(self, data: Any) -> str:
		"""Private method using conflicted names"""
		util_result = process_6(data)
		self.Logger.validate(str(data))
		self.Logger._log_process(f"Processing: {data}")
		self.result = f"user_model_process: {util_result}"
		return self.result

	def _user_validate(self, field: str, value: Any) -> bool:
		"""Private validation with name conflicts"""
		if field == "name":
			return isinstance(value, str) and len(value) > 0
		elif field == "email":
			return "@" in str(value) if value else True
		return False

	def authenticate(self, password: str) -> Dict[str, Any]:
		"""Method with complex internal conflicts"""
		validate = self.validate
		process = self.process
		Logger_2 = self.Logger
		result_3 = {}
		name_valid = validate("name", self.name)
		email_valid = validate("email", self.email)
		password_valid = len(password) >= 4
		auth_data = {"name": self.name, "email": self.email, "password_length": len(password)}
		process_result = process(auth_data)
		Logger_2.validate(f"auth_{self.name}")
		result_3 = {"user": self.name, "valid": name_valid and email_valid and password_valid, "process_result": process_result, "logger_context": Logger_2.context}
		return result_3

	def connect(self) -> str:
		"""Method with name that conflicts with global functions"""
		global connection_3
		connection_3 = f"user_model_connection_{self.name}"
		return connection_3
def process_user(data: Any) -> str:
	"""Module function with naming conflicts"""
	global result_3
	Logger_2 = globals()["Logger"]
	validate_4 = lambda x: x is not None
	logger = Logger_2("process_user")
	is_valid = validate_4(data)
	if is_valid:
		logger._log_process(f"Processing user data: {data}")
		processed = f"model_user_processed: {data}"
	else:
		processed = "model_user_invalid_data"
	result_3["last_process"] = processed
	return processed
def validate_4(user_data: Dict[str, Any]) -> bool:
	"""Module validate function - conflicts with other validates"""
	required_fields = ["name"]
	return all(field in user_data for field in required_fields)
def process_4(data: Any) -> str:
	"""Module process function - major conflict"""
	if isinstance(data, dict):
		return process_user(data)
	else:
		return f"model_process_generic: {data}"
class Connection_2:
	"""Model connection class - conflicts with other Connection classes"""

	def __init__(self, User: "User"):
		self.User = User_2
		self.connected = False

	def connect(self) -> str:
		self.connected = True
		return f"Model connection for user: {self.User.name}"

	def process(self, action: str) -> str:
		"""Method with conflicted name"""
		return f"connection_process: {action} for {self.User.name}"
def connect_2(User: "User") -> Connection_2:
	"""Module connect function with parameter conflicts"""
	return Connection_2(User_2)
def complex_operation(User: Any=None, Logger: Any=None, process: Any=None, validate: Any=None, result: Any=None, connection: Any=None) -> Dict[str, Any]:
	"""Function with all parameter names conflicting with globals/classes"""
	operation_result = {"user_param": User_2, "logger_param": Logger_2, "process_param": process_4, "validate_param": validate_4, "result_param": result_3, "connection_param": connection_3}
	User_2 = globals()["User"]
	Logger_2 = globals()["Logger"]
	if operation_result["user_param"]:
		user = User_2("complex_user")
		logger = Logger_2("complex_operation")
		operation_result["created_user"] = user.name
		operation_result["created_logger"] = logger.context
	return operation_result
process_4 = process_4
validate_4 = validate_4
User_2 = User_2
Logger_2 = Logger_2
connection_4 = "auth_connection_string"
Logger_3 = "services_logger_string"
result_4 = {"services": "initialized"}
Connection_4 = "utils_connection_type"
"""
Utility helpers module with extensive naming conflicts
"""
result_6 = 0
User_4 = "helper_user_string"
class Logger_4:
	"""Utility logger class - conflicts with other Logger classes"""

	def __init__(self, name: str):
		self.name = name
		self.messages: List[str] = []
		self.User = User_4

	def log(self, message: str) -> None:
		self.messages.append(f"[{self.name}] {message}")

	def get_message(self) -> str:
		return f"Utils Logger: {self.name}"

	def process(self, data: Any) -> str:
		"""Method with same name as module functions"""
		return f"logger_process: {data}"
def process_6(data: Any) -> str:
	"""Utility process function - major conflict with other process functions"""
	global result_6
	if isinstance(data, str):
		processed = data.upper()
	elif isinstance(data, (int, float)):
		processed = data * 2
	elif isinstance(data, dict):
		processed = {k: f"util_{v}" for k, v in data.items()}
	else:
		processed = str(data)
	result_6 += 1
	return f"util_processed: {processed}"
def validate_6(data: Any) -> bool:
	"""Utility validate function - conflicts with validate in other modules"""
	if data is None:
		return False
	if isinstance(data, str):
		return len(data) > 0
	elif isinstance(data, (list, dict)):
		return len(data) > 0
	elif isinstance(data, (int, float)):
		return data >= 0
	return True
class Connection_5:
	"""Utility connection class - name conflict with database Connection"""

	def __init__(self, connection_type: str="utility"):
		self.connection_type = connection_type
		self.active = False

	def connect(self) -> str:
		self.active = True
		return f"Utility connection: {self.connection_type}"
def connect_4() -> Connection_5:
	"""Utility connect function"""
	return Connection_5("helper")
def process_with_conflicts(data: Any, User: str="param_user", result: int=100, Logger: Any=None) -> Dict[str, Any]:
	"""Function with parameter names that conflict with globals and imports"""
	connection = connect_4()
	validate_result = validate_6(data)
	local_result = {"data": data, "user_param": User_4, "result_param": result_6, "logger_param": Logger_4, "validation": validate_result, "connection_type": connection.connection_type}
	return local_result
validate_6 = validate_6
process_6 = process_6
User_5 = "database_user_type"
"""
Database connection module with naming conflicts
"""
result_8 = []
connection_5 = None
class Connection_6:
	"""Database connection class"""

	def __init__(self, host="localhost", port=5432):
		self.host = host
		self.port = port
		self.connected = False
		self.result = None
		self.process = self._internal_process

	def _internal_process(self, query):
		return f"db_internal: {query}"

	def connect(self):
		global connection_5
		self.connected = True
		connection_5 = self
		return f"Connected to {self.host}:{self.port}"
def process_7(data):
	"""Database process function - conflicts with other process functions"""
	global result_8
	validated = validate_6(data)
	user_result = process_user(data)
	processed = {"db_process": True, "data": validated, "user_processing": user_result, "timestamp": "2024-01-01"}
	result_8.append(processed)
	return f"db_processed: {data}"
def validate_7(data):
	"""Database validate function - another conflict"""
	if not data:
		return False
	return f"db_valid: {data}"
def connect_5():
	"""Module-level connect function"""
	global connection_5
	if connection_5 is None:
		connection_5 = Connection_6()
	return connection_5.connect()
process_7 = process_7
__cribo_services_auth_manager_result = None
def __cribo_init___cribo_49b92c_services_auth_manager():
	if '__cribo_49b92c_services_auth_manager' in sys.modules:
		return sys.modules['__cribo_49b92c_services_auth_manager']
	module = types.ModuleType('__cribo_49b92c_services_auth_manager')
	module.__file__ = __file__ if '__file__' in globals() else None
	sys.modules['__cribo_49b92c_services_auth_manager'] = module
	sys.modules['services.auth.manager'] = module
	"""\nAuthentication manager with complex naming conflicts\n"""
	DBConnection = Connection_6
	module.DBConnection = DBConnection
	base = types.SimpleNamespace()
	base.result = result_models_base
	base.process = process_models_base_1
	base.BaseModel = BaseModel_models_base
	base.initialize = initialize_models_base
	base.validate = validate_models_base
	base.Logger = Logger_models_base
	base.connect = connect_models_base
	base.shadow_test = shadow_test_models_base
	result = "auth_result"
	module.result = result
	validate = lambda x: f"auth_lambda_validate: {x}"
	module.validate = validate

	class User:
		"""Auth User class - conflicts with other User classes/variables"""

		def __init__(self, username: str, password: str):
			self.username = username
			self.password = password
			self.authenticated = False
			self.result = None
			self.connection = None

		def authenticate(self) -> bool:
			"""Authenticate user with name conflicts"""
			validate = self._internal_validate
			result = validate(self.password)
			self.authenticated = result
			self.result = f"auth_user_{self.username}_{result}"
			return result

		def _internal_validate(self, password: str) -> bool:
			return len(password) >= 4

		def connect(self) -> str:
			"""Method with same name as global functions"""
			self.connection = DBConnection()
			return f"User {self.username} connected"
	module.User = User

	class Connection:
		"""Auth connection class - conflicts with DB Connection"""

		def __init__(self, auth_type: str="oauth"):
			self.auth_type = auth_type
			self.users = []

		def add_user(self, User: "User") -> None:
			"""Add user with parameter name conflict"""
			self.users.append(User)

		def process(self, User: str) -> str:
			"""Process with parameter name conflicts"""
			return f"auth_connection_process: {User}"
	module.Connection = Connection

	def process(data: Any) -> str:
		"""Auth process function - major conflict"""
		global __cribo_services_auth_manager_result
		result = __cribo_services_auth_manager_result
		base_init = base.initialize()
		if isinstance(data, str):
			validate = lambda x: x.startswith("auth_")
			validated = validate(data)
			processed = f"auth_str_{data}" if validated else f"invalid_auth_{data}"
		else:
			processed = f"auth_other_{data}"
		__cribo_services_auth_manager_result = f'{__cribo_services_auth_manager_result}_processed'
		return f"auth_processed: {processed}, base: {base_init}"
	module.process = process

	def validate(data: Any) -> str:
		"""Auth validate function - conflicts with other validate functions"""
		if not data:
			return "auth_invalid"
		module_validate = module.__dict__.get("validate")
		if module_validate and module_validate is not validate and callable(module_validate):
			lambda_result = module_validate(data)
		else:
			lambda_result = f"fallback_{data}"
		return f"auth_valid: {data}, lambda: {lambda_result}"
	module.validate = validate

	def connect(User: Optional["User"]=None) -> Connection:
		"""Connect function with parameter conflict"""
		connection = Connection("auth_manager")
		if User:
			connection.add_user(User)
		return connection
	module.connect = connect

	class AuthManager:
		"""Manager class with extensive conflicts"""

		def __init__(self):
			self.connections = []
			self.users = []
			self.process = self._manager_process
			self.validate = self._manager_validate
			self.User = None

		def _manager_process(self, data: Any) -> str:
			return f"manager_process: {data}"

		def _manager_validate(self, data: Any) -> bool:
			return data is not None

		def add_user(self, username: str, password: str) -> "User":
			"""Method that creates User with local scope conflicts"""
			User = globals()["User"]
			user = User(username, password)
			self.users.append(user)
			self.User = user
			return user

		def process_all(self) -> Dict[str, Any]:
			"""Method using conflicting names throughout"""
			result = []
			for User in self.users:
				user_result = process(User.username)
				validate_result = validate(User.password)
				connection = connect(User)
				connection_process = connection.process(User.username)
				result.append({"user": User.username, "process": user_result, "validate": validate_result, "connection": connection_process})
			return {"manager_results": result}
	module.AuthManager = AuthManager
	global __cribo_services_auth_manager_result
	__cribo_services_auth_manager_result = result
	return module
def __cribo_init___cribo_62c387_core():
	if '__cribo_62c387_core' in sys.modules:
		return sys.modules['__cribo_62c387_core']
	module = types.ModuleType('__cribo_62c387_core')
	module.__file__ = __file__ if '__file__' in globals() else None
	sys.modules['__cribo_62c387_core'] = module
	sys.modules['core'] = module
	CoreLogger = Logger_4
	module.CoreLogger = CoreLogger
	core_process = process_6
	module.core_process = core_process
	result = "core_package_result"
	module.result = result
	Logger = CoreLogger
	module.Logger = Logger
	return module
__cribo_modules = {'services.auth.manager': '__cribo_49b92c_services_auth_manager', 'core': '__cribo_62c387_core'}
__cribo_init_functions = {'__cribo_49b92c_services_auth_manager': __cribo_init___cribo_49b92c_services_auth_manager, '__cribo_62c387_core': __cribo_init___cribo_62c387_core}
class CriboBundledFinder:

	def __init__(self, module_registry, init_functions):
		self.module_registry = module_registry
		self.init_functions = init_functions

	def find_spec(self, fullname, path, target=None):
		if fullname in self.module_registry:
			synthetic_name = self.module_registry[fullname]
			if synthetic_name not in sys.modules:
				init_func = self.init_functions.get(synthetic_name)
				if init_func:
					init_func()
			import importlib.util
			return importlib.util.find_spec(synthetic_name)
		return None
sys.meta_path.insert(0, CriboBundledFinder(__cribo_modules, __cribo_init_functions))
__cribo_init___cribo_49b92c_services_auth_manager()
__cribo_init___cribo_62c387_core()
"""
Comprehensive AST rewriter test fixture - Main entry point
This module demonstrates complex naming conflicts and import scenarios
"""
db_process = process_7
process = process_6
UtilLogger = Logger_4
validate = validate_6
auth_process = sys.modules['services.auth.manager'].process
User = sys.modules['services.auth.manager'].User
auth_validate = sys.modules['services.auth.manager'].validate
UserModel = User_2
Logger = Logger_2
base = types.SimpleNamespace()
base.result = result_models_base
base.process = process_models_base_1
base.BaseModel = BaseModel_models_base
base.initialize = initialize_models_base
base.validate = validate_models_base
base.Logger = Logger_models_base
base.connect = connect_models_base
base.shadow_test = shadow_test_models_base
result_1 = 42
result = result_1
connection_1 = None
connection = connection_1
def validate_1(data):
	"""This validate function conflicts with imported validate functions"""
	return f"main_validate: {data}"
validate = validate_1
def process_1(data):
	"""This process function conflicts with multiple imported process functions"""
	return f"main_process: {data}"
process = process_1
class User_1:
	"""This User class conflicts with imported User classes"""

	def __init__(self, name):
		self.name = name
		self.result = self._process_name(name)

	def _process_name(self, name):
		return f"main_user: {name}"
User = User_1
class Connection_1:
	"""Connection class that conflicts with database connection"""

	def __init__(self):
		self.status = "disconnected"

	def connect(self):
		global connection_1
		connection_1 = self
		return "main_connection_established"
Connection = Connection_1
def main():
	"""Main function demonstrating all the conflicts in action"""
	db_result = db_process("database_data")
	util_result = process("utility_data")
	auth_result = auth_process("auth_data")
	util_logger = UtilLogger("util")
	model_logger = Logger("model")
	auth_user = User("auth_type")
	model_user = UserModel("model_type")
	service_user = User("service_type")
	local_validate_result = validate("local_data")
	auth_validate_result = auth_validate("auth_data")
	util_validate_result = validate("util_data")
	result = db_result + util_result + auth_result
	base_result = base.initialize()
	final_result = {"process_results": [db_result, util_result, auth_result], "validation_results": [local_validate_result, auth_validate_result, util_validate_result], "user_types": [auth_user.name, model_user.name, service_user.name], "logger_messages": [util_logger.get_message(), model_logger.get_message()], "base_init": base_result, "total": result + str(globals()["result"])}
	return final_result
if __name__ == "__main__":
	connection_1 = Connection_1()
	connection_1.connect()
	results = main()
	print("Comprehensive AST rewriter test completed")
	print(f"Final results: {results}")
