---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/bundling/xfail_comprehensive_ast_rewrite/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

from typing import Any, Dict, List, Optional
import sys
import types
"""\nUser model with extensive naming conflicts across the project\n"""
result_3 = {"model": "user"}
connection_3 = None
class Logger_2:
    """Model Logger class - conflicts with other Logger classes"""

    def __init__(self, context: str):
        self.context = context
        self.entries = []
        self.process = self._log_process

    def _log_process(self, message: str) -> None:
        self.entries.append(f"{self.context}: {message}")

    def get_message(self) -> str:
        return f"Model Logger: {self.context}"

    def validate(self, entry: str) -> bool:
        """Method with name that conflicts with global functions"""
        return len(entry) > 0
class User_2:
    """Model User class - major conflict with other User classes"""

    def __init__(self, name: str, email: str=""):
        self.name = name
        self.email = email
        self.active = True
        self.Logger = Logger_2(f"user_{name}")
        self.process = self._user_process
        self.validate = self._user_validate
        self.result = None

    def _user_process(self, data: Any) -> str:
        """Private method using conflicted names"""
        util_result = process_6(data)
        self.Logger.validate(str(data))
        self.Logger._log_process(f"Processing: {data}")
        self.result = f"user_model_process: {util_result}"
        return self.result

    def _user_validate(self, field: str, value: Any) -> bool:
        """Private validation with name conflicts"""
        if field == "name":
            return isinstance(value, str) and len(value) > 0
        elif field == "email":
            return "@" in str(value) if value else True
        return False

    def authenticate(self, password: str) -> Dict[str, Any]:
        """Method with complex internal conflicts"""
        validate = self.validate
        process = self.process
        Logger_2 = self.Logger
        result_3 = {}
        name_valid = validate("name", self.name)
        email_valid = validate("email", self.email)
        password_valid = len(password) >= 4
        auth_data = {"name": self.name, "email": self.email, "password_length": len(password)}
        process_result = process(auth_data)
        Logger_2.validate(f"auth_{self.name}")
        result_3 = {"user": self.name, "valid": name_valid and email_valid and password_valid, "process_result": process_result, "logger_context": Logger_2.context}
        return result_3

    def connect(self) -> str:
        """Method with name that conflicts with global functions"""
        global connection_3
        connection_3 = f"user_model_connection_{self.name}"
        return connection_3
def process_user(data: Any) -> str:
    """Module function with naming conflicts"""
    global result_3
    Logger_2 = globals()["Logger"]
    validate_4 = lambda x: x is not None
    logger = Logger_2("process_user")
    is_valid = validate_4(data)
    if is_valid:
        logger._log_process(f"Processing user data: {data}")
        processed = f"model_user_processed: {data}"
    else:
        processed = "model_user_invalid_data"
    result_3["last_process"] = processed
    return processed
def validate_4(user_data: Dict[str, Any]) -> bool:
    """Module validate function - conflicts with other validates"""
    required_fields = ["name"]
    return all(field in user_data for field in required_fields)
def process_4(data: Any) -> str:
    """Module process function - major conflict"""
    if isinstance(data, dict):
        return process_user(data)
    else:
        return f"model_process_generic: {data}"
class Connection_2:
    """Model connection class - conflicts with other Connection classes"""

    def __init__(self, User: "User"):
        self.User = User_2
        self.connected = False

    def connect(self) -> str:
        self.connected = True
        return f"Model connection for user: {self.User.name}"

    def process(self, action: str) -> str:
        """Method with conflicted name"""
        return f"connection_process: {action} for {self.User.name}"
def connect_2(User: "User") -> Connection_2:
    """Module connect function with parameter conflicts"""
    return Connection_2(User_2)
def complex_operation(User: Any=None, Logger: Any=None, process: Any=None, validate: Any=None, result: Any=None, connection: Any=None) -> Dict[str, Any]:
    """Function with all parameter names conflicting with globals/classes"""
    operation_result = {"user_param": User_2, "logger_param": Logger_2, "process_param": process_4, "validate_param": validate_4, "result_param": result_3, "connection_param": connection_3}
    User_2 = globals()["User"]
    Logger_2 = globals()["Logger"]
    if operation_result["user_param"]:
        user = User_2("complex_user")
        logger = Logger_2("complex_operation")
        operation_result["created_user"] = user.name
        operation_result["created_logger"] = logger.context
    return operation_result
process_4 = process_4
validate_4 = validate_4
User_2 = User_2
Logger_2 = Logger_2
"""\nDatabase connection module with naming conflicts\n"""
result_8 = []
connection_5 = None
class Connection_6:
    """Database connection class"""

    def __init__(self, host="localhost", port=5432):
        self.host = host
        self.port = port
        self.connected = False
        self.result = None
        self.process = self._internal_process

    def _internal_process(self, query):
        return f"db_internal: {query}"

    def connect(self):
        global connection_5
        self.connected = True
        connection_5 = self
        return f"Connected to {self.host}:{self.port}"
def process_7(data):
    """Database process function - conflicts with other process functions"""
    global result_8
    validated = validate_6(data)
    user_result = process_user(data)
    processed = {"db_process": True, "data": validated, "user_processing": user_result, "timestamp": "2024-01-01"}
    result_8.append(processed)
    return f"db_processed: {data}"
def validate_7(data):
    """Database validate function - another conflict"""
    if not data:
        return False
    return f"db_valid: {data}"
def connect_5():
    """Module-level connect function"""
    global connection_5
    if connection_5 is None:
        connection_5 = Connection_6()
    return connection_5.connect()
process_7 = process_7
User_5 = "database_user_type"
"""\nUtility helpers module with extensive naming conflicts\n"""
result_6 = 0
User_4 = "helper_user_string"
class Logger_4:
    """Utility logger class - conflicts with other Logger classes"""

    def __init__(self, name: str):
        self.name = name
        self.messages: List[str] = []
        self.User = User_4

    def log(self, message: str) -> None:
        self.messages.append(f"[{self.name}] {message}")

    def get_message(self) -> str:
        return f"Utils Logger: {self.name}"

    def process(self, data: Any) -> str:
        """Method with same name as module functions"""
        return f"logger_process: {data}"
def process_6(data: Any) -> str:
    """Utility process function - major conflict with other process functions"""
    global result_6
    if isinstance(data, str):
        processed = data.upper()
    elif isinstance(data, (int, float)):
        processed = data * 2
    elif isinstance(data, dict):
        processed = {k: f"util_{v}" for k, v in data.items()}
    else:
        processed = str(data)
    result_6 += 1
    return f"util_processed: {processed}"
def validate_6(data: Any) -> bool:
    """Utility validate function - conflicts with validate in other modules"""
    if data is None:
        return False
    if isinstance(data, str):
        return len(data) > 0
    elif isinstance(data, (list, dict)):
        return len(data) > 0
    elif isinstance(data, (int, float)):
        return data >= 0
    return True
class Connection_5:
    """Utility connection class - name conflict with database Connection"""

    def __init__(self, connection_type: str="utility"):
        self.connection_type = connection_type
        self.active = False

    def connect(self) -> str:
        self.active = True
        return f"Utility connection: {self.connection_type}"
def connect_4() -> Connection_5:
    """Utility connect function"""
    return Connection_5("helper")
def process_with_conflicts(data: Any, User: str="param_user", result: int=100, Logger: Any=None) -> Dict[str, Any]:
    """Function with parameter names that conflict with globals and imports"""
    connection = connect_4()
    validate_result = validate_6(data)
    local_result = {"data": data, "user_param": User_4, "result_param": result_6, "logger_param": Logger_4, "validation": validate_result, "connection_type": connection.connection_type}
    return local_result
validate_6 = validate_6
process_6 = process_6
Connection_4 = "utils_connection_type"
"""\nBase model functionality with relative import conflicts\n"""
result_2 = "base_result"
process_2 = "base_process_string"
class BaseModel:
    """Base model class with method name conflicts"""

    def __init__(self, model_type: str):
        self.model_type = model_type
        self.initialized = False
        self.validate = self._base_validate
        self.process = self._base_process
        self.Logger = Logger_2("base_model")

    def _base_validate(self, data: Any) -> bool:
        """Base validation using relative imports"""
        return validate_6(data)

    def _base_process(self, data: Any) -> str:
        """Base processing with conflicts"""
        validated = self.validate(data)
        if validated:
            self.Logger._log_process(f"Base processing: {data}")
            return f"base_processed: {data}"
        return "base_invalid"

    def initialize(self) -> str:
        """Initialize with name conflicts"""
        global result_2
        self.initialized = True
        result_2 = f"base_initialized_{self.model_type}"
        return result_2
def initialize() -> str:
    """Module initialization function"""
    global result_2
    base = BaseModel("default")
    init_result = base.initialize()
    logger = Logger_2("base_init")
    logger._log_process("Base module initialized")
    result_2 = f"module_init: {init_result}"
    return result_2
def validate_2(data: Any) -> bool:
    """Base validate function - conflicts everywhere"""
    return validate_6(data) and data != "invalid"
def process_2(data: Any) -> str:
    """Base process function - conflicts everywhere"""
    global result_2
    validated = validate_2(data)
    if validated:
        processed = f"base_module_process: {data}"
    else:
        processed = "base_module_invalid"
    result_2 = f"base_last_process: {processed}"
    return processed
class Logger_1:
    """Base Logger class - yet another Logger conflict"""

    def __init__(self, source: str):
        self.source = source
        self.logs = []

    def log(self, message: str) -> None:
        self.logs.append(f"[BASE {self.source}] {message}")

    def process(self, log_data: Any) -> str:
        """Logger process method - conflicts with global process"""
        self.log(f"Processing: {log_data}")
        return f"base_logger_process: {log_data}"
def connect_1() -> str:
    """Base connect function"""
    return "base_connected"
def shadow_test(validate: Any=None, process: Any=None, Logger: Any=None, result: Any=None, initialize: Any=None) -> Dict[str, Any]:
    """Function that shadows all major conflict names with parameters"""
    shadows = {"validate_param": validate_2, "process_param": process_2, "Logger_param": Logger_1, "result_param": result_2, "initialize_param": initialize}
    validate_2 = globals()["validate"]
    process_2 = globals()["process"]
    Logger_1 = globals()["Logger"]
    validation_result = validate_2("test_data")
    process_result = process_2("test_data")
    logger = Logger_1("shadow_test")
    shadows.update({"global_validate_result": validation_result, "global_process_result": process_result, "global_logger_source": logger.source})
    return shadows
validate_2 = validate_2
process_2 = process_2
Logger_1 = Logger_1
initialize = initialize
connection_4 = "auth_connection_string"
process_3 = "models_process_string"
validate_3 = "models_validate_string"
connection_2 = "models_connection_string"
Logger_3 = "services_logger_string"
result_4 = {"services": "initialized"}
__cribo_services_auth_manager_result = None
def __cribo_init___cribo_49b92c_services_auth_manager():
    if '__cribo_49b92c_services_auth_manager' in sys.modules:
        return sys.modules['__cribo_49b92c_services_auth_manager']
    module = types.ModuleType('__cribo_49b92c_services_auth_manager')
    module.__file__ = __file__ if '__file__' in globals() else None
    sys.modules['__cribo_49b92c_services_auth_manager'] = module
    sys.modules['services.auth.manager'] = module
    """\nAuthentication manager with complex naming conflicts\n"""
    DBConnection = Connection_6
    module.DBConnection = DBConnection
    base = types.SimpleNamespace()
    base.result = result_2
    base.process = process_2
    base.validate = validate_2
    base.Logger = Logger_1
    base.connect = connect_1
    result = "auth_result"
    module.result = result
    validate = lambda x: f"auth_lambda_validate: {x}"
    module.validate = validate

    class User:
        """Auth User class - conflicts with other User classes/variables"""

        def __init__(self, username: str, password: str):
            self.username = username
            self.password = password
            self.authenticated = False
            self.result = None
            self.connection = None

        def authenticate(self) -> bool:
            """Authenticate user with name conflicts"""
            validate = self._internal_validate
            result = validate(self.password)
            self.authenticated = result
            self.result = f"auth_user_{self.username}_{result}"
            return result

        def _internal_validate(self, password: str) -> bool:
            return len(password) >= 4

        def connect(self) -> str:
            """Method with same name as global functions"""
            self.connection = DBConnection()
            return f"User {self.username} connected"
    module.User = User

    class Connection:
        """Auth connection class - conflicts with DB Connection"""

        def __init__(self, auth_type: str="oauth"):
            self.auth_type = auth_type
            self.users = []

        def add_user(self, User: "User") -> None:
            """Add user with parameter name conflict"""
            self.users.append(User)

        def process(self, User: str) -> str:
            """Process with parameter name conflicts"""
            return f"auth_connection_process: {User}"
    module.Connection = Connection

    def process(data: Any) -> str:
        """Auth process function - major conflict"""
        global __cribo_services_auth_manager_result
        result = __cribo_services_auth_manager_result
        base_init = base.initialize()
        if isinstance(data, str):
            validate = lambda x: x.startswith("auth_")
            validated = validate(data)
            processed = f"auth_str_{data}" if validated else f"invalid_auth_{data}"
        else:
            processed = f"auth_other_{data}"
        __cribo_services_auth_manager_result = f'{__cribo_services_auth_manager_result}_processed'
        return f"auth_processed: {processed}, base: {base_init}"
    module.process = process

    def validate(data: Any) -> str:
        """Auth validate function - conflicts with other validate functions"""
        if not data:
            return "auth_invalid"
        module_validate = module.__dict__.get("validate")
        if module_validate and module_validate is not validate and callable(module_validate):
            lambda_result = module_validate(data)
        else:
            lambda_result = f"fallback_{data}"
        return f"auth_valid: {data}, lambda: {lambda_result}"
    module.validate = validate

    def connect(User: Optional["User"]=None) -> Connection:
        """Connect function with parameter conflict"""
        connection = Connection("auth_manager")
        if User:
            connection.add_user(User)
        return connection
    module.connect = connect

    class AuthManager:
        """Manager class with extensive conflicts"""

        def __init__(self):
            self.connections = []
            self.users = []
            self.process = self._manager_process
            self.validate = self._manager_validate
            self.User = None

        def _manager_process(self, data: Any) -> str:
            return f"manager_process: {data}"

        def _manager_validate(self, data: Any) -> bool:
            return data is not None

        def add_user(self, username: str, password: str) -> "User":
            """Method that creates User with local scope conflicts"""
            User = globals()["User"]
            user = User(username, password)
            self.users.append(user)
            self.User = user
            return user

        def process_all(self) -> Dict[str, Any]:
            """Method using conflicting names throughout"""
            result = []
            for User in self.users:
                user_result = process(User.username)
                validate_result = validate(User.password)
                connection = connect(User)
                connection_process = connection.process(User.username)
                result.append({"user": User.username, "process": user_result, "validate": validate_result, "connection": connection_process})
            return {"manager_results": result}
    module.AuthManager = AuthManager
    global __cribo_services_auth_manager_result
    __cribo_services_auth_manager_result = result
    return module
def __cribo_init___cribo_62c387_core():
    if '__cribo_62c387_core' in sys.modules:
        return sys.modules['__cribo_62c387_core']
    module = types.ModuleType('__cribo_62c387_core')
    module.__file__ = __file__ if '__file__' in globals() else None
    sys.modules['__cribo_62c387_core'] = module
    sys.modules['core'] = module
    CoreLogger = Logger_4
    module.CoreLogger = CoreLogger
    core_process = process_6
    module.core_process = core_process
    result = "core_package_result"
    module.result = result
    Logger = CoreLogger
    module.Logger = Logger
    return module
__cribo_modules = {'services.auth.manager': '__cribo_49b92c_services_auth_manager', 'core': '__cribo_62c387_core'}
__cribo_init_functions = {'__cribo_49b92c_services_auth_manager': __cribo_init___cribo_49b92c_services_auth_manager, '__cribo_62c387_core': __cribo_init___cribo_62c387_core}
class CriboBundledFinder:

    def __init__(self, module_registry, init_functions):
        self.module_registry = module_registry
        self.init_functions = init_functions

    def find_spec(self, fullname, path, target=None):
        if fullname in self.module_registry:
            synthetic_name = self.module_registry[fullname]
            if synthetic_name not in sys.modules:
                init_func = self.init_functions.get(synthetic_name)
                if init_func:
                    init_func()
            import importlib.util
            return importlib.util.find_spec(synthetic_name)
        return None
sys.meta_path.insert(0, CriboBundledFinder(__cribo_modules, __cribo_init_functions))
__cribo_init___cribo_49b92c_services_auth_manager()
__cribo_init___cribo_62c387_core()
"""\nComprehensive AST rewriter test fixture - Main entry point\nThis module demonstrates complex naming conflicts and import scenarios\n"""
db_process = process_7
process = process_6
UtilLogger = Logger_4
validate = validate_6
auth_process = sys.modules['services.auth.manager'].process
User = sys.modules['services.auth.manager'].User
auth_validate = sys.modules['services.auth.manager'].validate
UserModel = User_2
Logger = Logger_2
base = types.SimpleNamespace()
base.result = result_2
base.process = process_2
base.validate = validate_2
base.Logger = Logger_1
base.connect = connect_1
result_1 = 42
result = result_1
connection_1 = None
connection = connection_1
def validate_1(data):
    """This validate function conflicts with imported validate functions"""
    return f"main_validate: {data}"
validate = validate_1
def process_1(data):
    """This process function conflicts with multiple imported process functions"""
    return f"main_process: {data}"
process = process_1
class User_1:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
User = User_1
class Connection_1:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection_1
        connection_1 = self
        return "main_connection_established"
Connection = Connection_1
def main():
    """Main function demonstrating all the conflicts in action"""
    db_result = db_process("database_data")
    util_result = process("utility_data")
    auth_result = auth_process("auth_data")
    util_logger = UtilLogger("util")
    model_logger = Logger("model")
    auth_user = User("auth_type")
    model_user = UserModel("model_type")
    service_user = User("service_type")
    local_validate_result = validate("local_data")
    auth_validate_result = auth_validate("auth_data")
    util_validate_result = validate("util_data")
    result = db_result + util_result + auth_result
    base_result = base.initialize()
    final_result = {"process_results": [db_result, util_result, auth_result], "validation_results": [local_validate_result, auth_validate_result, util_validate_result], "user_types": [auth_user.name, model_user.name, service_user.name], "logger_messages": [util_logger.get_message(), model_logger.get_message()], "base_init": base_result, "total": result + str(globals()["result"])}
    return final_result
if __name__ == "__main__":
    connection_1 = Connection_1()
    connection_1.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
